name: serialize_seed_sections
description: Section-specific prompts for iterative SEED serialization

# Section 1: Entity Decisions
entities_prompt: |
  You are generating ENTITY DECISIONS for a SEED stage.

  ## Generation Requirements (CRITICAL)
  You MUST generate a decision for EVERY entity ID in the manifest below.
  Missing items WILL cause validation failure. This is NOT extraction - you must
  generate decisions for ALL entities, even if the brief doesn't mention them explicitly.

  ## Scoped ID Format (CRITICAL)
  All IDs use type prefixes for disambiguation. Copy IDs EXACTLY as shown in the manifest,
  including the CATEGORY prefix (`character::`, `location::`, `item::`, or `faction::`).

  ## Schema
  Return a JSON object with an "entities" array. Each item is an EntityDecision:
  ```json
  {
    "entities": [
      {
        "entity_id": "character::butler",
        "disposition": "retained"
      },
      {
        "entity_id": "location::manor",
        "disposition": "cut"
      }
    ]
  }
  ```

  ## Rules
  - disposition must be exactly "retained" or "cut" (lowercase)
  - entity_id must include the category prefix and match EXACTLY an ID from the manifest
  - Generate a decision for EVERY entity in the manifest

  ## What NOT to Do
  - Do NOT skip entities because they aren't mentioned in the brief
  - Do NOT invent entities not in the manifest
  - Do NOT partially complete the list
  - Do NOT omit the category prefix from IDs

  ## Output
  Return ONLY valid JSON with the "entities" array.

# Section 2: Dilemma Decisions
dilemmas_prompt: |
  You are generating DILEMMA DECISIONS for a SEED stage.

  ## Generation Requirements (CRITICAL)
  You MUST generate a decision for EVERY dilemma ID in the manifest below.
  Missing items WILL cause validation failure. This is NOT extraction - you must
  generate decisions for ALL dilemmas, even if the brief doesn't mention them explicitly.

  ## Scoped ID Format (CRITICAL)
  All IDs use type prefixes for disambiguation. Copy dilemma IDs EXACTLY as shown in
  the manifest, including the `dilemma::` prefix.

  ## Schema
  Return a JSON object with a "dilemmas" array. Each item is a DilemmaDecision:
  ```json
  {
    "dilemmas": [
      {
        "dilemma_id": "dilemma::host_benevolent_or_selfish",
        "explored": ["protector", "manipulator"],
        "unexplored": []
      }
    ]
  }
  ```

  Note: `explored` and `unexplored` contain raw answer IDs (no prefix) since
  they are local to each dilemma.

  ## Rules
  - dilemma_id must include the `dilemma::` prefix and match EXACTLY an ID from the manifest
  - explored: Answer IDs to explore as paths (MUST include the default path)
  - unexplored: Answer IDs NOT explored (become shadows)
  - Generate a decision for EVERY dilemma in the manifest

  ## CRITICAL INVARIANT: explored ↔ paths linkage
  The `explored` array defines which answers will have paths created.
  For EACH answer_id in `explored`, you MUST create a path later.
  The path's `answer_id` field MUST match an entry in `explored`.

  WRONG: `explored: []` with paths that have `answer_id` values
  WRONG: `explored: ["opt_a"]` but path uses `answer_id: "opt_b"`
  RIGHT: `explored: ["opt_a", "opt_b"]` and paths use those exact IDs

  ## Tension Balance: How Many Answers to Explore

  Exploring more answers creates more paths, more branching, and a larger story.
  Leaving answers unexplored creates dramatic shadows — tensions that are felt
  but never resolved, adding subtext and replayability.

  GOOD tension balance:
  - Dilemma with 2 answers: explore BOTH (2 paths). This is the default —
    binary dilemmas are designed to create two-path branching.
  - Dilemma with 3+ answers: explore 2, leave 1 unexplored. The unexplored
    answer becomes an intriguing "road not taken" that enriches the narrative.

  BAD tension balance:
  - Exploring ALL answers of every dilemma: creates too many paths, dilutes
    each path's narrative weight. The story becomes wide but shallow.
  - Exploring only 1 answer per dilemma: eliminates meaningful branching.
    Players have no real choice, defeating the purpose of the dilemma.
  - Leaving ALL answers unexplored: no paths are created. The dilemma has
    no gameplay impact.

  GUIDELINE: Aim for 2-4 total paths. For a vignette scope, 2 paths is
  ideal. For a full story, 3-4 paths provide rich branching without
  overwhelming the GROW stage.

  ## What NOT to Do
  - Do NOT skip dilemmas because they aren't mentioned in the brief
  - Do NOT invent dilemmas not in the manifest
  - Do NOT partially complete the list
  - Do NOT leave `explored` empty if you plan to create paths for that dilemma
  - Do NOT omit the `dilemma::` prefix from dilemma_id

  ## Output
  Return ONLY valid JSON with the "dilemmas" array.

# Section 3: Paths
paths_prompt: |
  You are generating PATHS for a SEED stage based on dilemma decisions.

  ## Generation Requirements (CRITICAL)
  For each "explored" answer in the dilemma decisions, you MUST generate a path.
  Each path represents one storyline that will be developed in the story.

  ## Scoped ID Format (CRITICAL)
  All IDs use type prefixes for disambiguation:
  - path_id: Use hierarchical `path::` prefix (e.g., `path::host_benevolent_or_selfish__protector`)
  - dilemma_id: Use `dilemma::` prefix (e.g., `dilemma::host_benevolent_or_selfish`)

  Path IDs embed their parent dilemma: `path::[dilemma_name]__[answer_id]`

  Copy IDs EXACTLY as shown in the manifest, including the prefixes.

  ## CRITICAL INVARIANT: answer_id MUST match explored
  Each path's `answer_id` MUST be one of the IDs listed in the dilemma's
  `explored` array. This is a hard constraint enforced by validation.

  WRONG: Path with `answer_id: "option_b"` when dilemma has `explored: ["option_a"]`
  RIGHT: Path with `answer_id: "option_a"` when dilemma has `explored: ["option_a", "option_b"]`

  ## Schema
  Return a JSON object with a "paths" array. Each item is a Path:
  ```json
  {
    "paths": [
      {
        "path_id": "path::host_benevolent_or_selfish__protector",
        "name": "The Host's Hidden Motive",
        "dilemma_id": "dilemma::host_benevolent_or_selfish",
        "answer_id": "protector",
        "unexplored_answer_ids": ["manipulator"],
        "path_importance": "major",
        "description": "What this path is about",
        "consequence_ids": ["host_revealed"]
      }
    ]
  }
  ```

  Note: `answer_id`, `unexplored_answer_ids`, and `consequence_ids` are raw
  IDs without prefixes since they are local identifiers.

  ## Path ID Naming (CRITICAL)

  Path IDs use hierarchical format that embeds the parent dilemma:
  `path::[dilemma_name]__[answer_id]`

  This prevents misreferences since the parent dilemma is embedded in the ID.

  Pattern examples (generate YOUR OWN based on your story):
  - Dilemma `dilemma::mentor_trust_or_betray` with answer `trust` → Path: `path::mentor_trust_or_betray__trust`
  - Dilemma `dilemma::artifact_blessed_or_cursed` with answer `blessed` → Path: `path::artifact_blessed_or_cursed__blessed`

  BAD patterns (will cause validation failures):
  - Using the SAME ID for both dilemma and path
  - Missing the `__` separator
  - Omitting the `path::` prefix

  **DO NOT copy example IDs** - generate IDs specific to YOUR story.

  ## Rules
  - path_importance must be exactly "major" or "minor" (lowercase)
  - unexplored_answer_ids: IDs of answers NOT explored (unexplored ones)
  - consequence_ids: References to consequences for this path
  - Generate a path for EACH explored answer from dilemma decisions
  - answer_id MUST be one of the IDs from the dilemma's `explored` array
  - path_id MUST include the `path::` prefix and use hierarchical format
  - dilemma_id MUST include the `dilemma::` prefix

  ## What NOT to Do
  - Do NOT reuse dilemma IDs as path IDs
  - Do NOT skip answers marked as "explored"
  - Do NOT create paths for "unexplored" answers (they become shadows, not paths)
  - Do NOT use an answer_id that isn't in the dilemma's `explored` list
  - Do NOT omit the `path::` or `dilemma::` prefixes

  ## Output
  Return ONLY valid JSON with the "paths" array.

# Section 4: Consequences
consequences_prompt: |
  You are generating CONSEQUENCES for a SEED stage based on paths.

  ## Generation Requirements (CRITICAL)
  Every path MUST have at least one consequence. Consequences describe the narrative
  outcomes that result from following a particular path's storyline.

  ## Scoped ID Format (CRITICAL)
  Path IDs use the `path::` prefix for disambiguation.
  Copy path IDs EXACTLY as shown in the VALID PATH IDs list.

  ## Schema
  Return a JSON object with a "consequences" array. Each item is a Consequence:
  ```json
  {
    "consequences": [
      {
        "consequence_id": "host_revealed",
        "path_id": "path::host_benevolent_or_selfish__protector",
        "description": "What happens narratively",
        "narrative_effects": ["story effect 1", "story effect 2"]
      }
    ]
  }
  ```

  Note: `consequence_id` is a raw ID without prefix (local identifier).
  `path_id` MUST include the `path::` prefix.

  ## Consequence ID Naming Convention

  Use descriptive names that capture the narrative outcome:
  - FORMAT: `[subject]_[outcome]` (e.g., `host_revealed`, `trust_broken`, `secret_exposed`)
  - Keep IDs short and descriptive (2-4 words joined by underscores)
  - Avoid generic names like `consequence_1` or `result_a`

  EXAMPLES:
  - `vault_sealed` - The vault is permanently sealed
  - `alliance_formed` - Characters form an alliance
  - `identity_exposed` - A hidden identity is revealed

  ## Rules
  - consequence_id must be unique (raw ID, no prefix, following naming convention above)
  - path_id must include the `path::` prefix and reference a path from the VALID PATH IDs list
  - narrative_effects: Array of story effects this consequence implies
  - Generate at least one consequence for EACH path

  ## What NOT to Do
  - Do NOT reference path IDs that don't exist
  - Do NOT leave any path without consequences
  - Do NOT use generic consequence IDs like `consequence_1` (use descriptive names)
  - Do NOT omit the `path::` prefix from path_id

  ## Output
  Return ONLY valid JSON with the "consequences" array.

# Section 5: Initial Beats
beats_prompt: |
  You are generating INITIAL BEATS for a SEED stage.

  ## Generation Requirements (CRITICAL)
  Generate 2-4 initial beats PER PATH. If there are 3 paths, expect 6-12 beats total.
  Beats must use ONLY valid IDs from the manifest - no invented or derived IDs.

  ## CRITICAL: ID CONSTRAINTS (read first!)

  The brief contains valid ID lists. You MUST copy IDs exactly from these lists:
  - `## VALID PATH IDs` - use ONLY these in `paths` arrays
  - `### Entity IDs` - use ONLY these in `entities` and `location` fields

  WRONG examples that WILL FAIL:
  - `"clock_distortion"` - NOT a valid path (derived from concept)
  - `"the_garden"` - WRONG, use `"garden"` (no prefix)
  - `"murder_intent"` - This is a dilemma ID, not a path ID
  - `"seed_of_stillness"` as dilemma_id - WRONG, this is an entity (no `_or_` = not a dilemma)

  ## Schema
  Return a JSON object with an "initial_beats" array:
  ```json
  {
    "initial_beats": [
      {
        "beat_id": "unique_beat_id",
        "summary": "What happens in this beat",
        "paths": ["path::[your_path_id]", "path::[another_path]"],
        "dilemma_impacts": [
          {
            "dilemma_id": "dilemma::[your_dilemma_id]",
            "effect": "advances",
            "note": "Explanation of the impact"
          }
        ],
        "entities": ["character::[character_id]", "location::[location_id]"],
        "location": "location::[location_id]",
        "location_alternatives": ["location::[other_location]"]
      }
    ]
  }
  ```

  **Use IDs from YOUR story's manifest** - the examples above show the FORMAT only.

  ## Rules
  - effect must be exactly "advances", "reveals", "commits", or "complicates"
  - All ID fields must use the correct type (see FIELD → ID TYPE MAPPING below)
  - location can be null; location_alternatives can be empty array
  - Generate 2-4 beats for EACH path in the VALID PATH IDs list
  - dilemma_impacts MUST use dilemma IDs from the Dilemma IDs list — NOT entity names

  ## DILEMMA IMPACT CONSTRAINT (MOST IMPORTANT RULE)

  Every beat belongs to a path. Every path has a PARENT DILEMMA (shown in the
  PATH → DILEMMA MAPPING in your brief). The beat's dilemma_impacts MUST include
  the parent dilemma of the beat's path.

  RULE: Look up the beat's path in PATH → DILEMMA MAPPING. Use THAT dilemma_id.

  EXAMPLE (format only - use YOUR story's IDs):
  - If path `path::keeper_faithful_or_corrupt__faithful` maps to `dilemma::keeper_faithful_or_corrupt`
  - Then ALL beats in that path MUST have a dilemma_impact with
    `dilemma_id: "dilemma::keeper_faithful_or_corrupt"`

  WRONG: Picking a dilemma because it "feels related" to the beat's content.
  WRONG: Using the same dilemma for all beats regardless of path.
  RIGHT: Using the PATH → DILEMMA MAPPING to find the correct dilemma.

  A beat MAY have additional dilemma_impacts for other dilemmas, but the FIRST
  dilemma_impact MUST be the path's parent dilemma.

  ## COMMITS BEATS REQUIREMENT (CRITICAL)

  Each path MUST have at least one beat with `effect: "commits"` — and that
  commits beat MUST reference the path's OWN parent dilemma (from the mapping).

  WRONG: All commits beats using the same dilemma_id.
  RIGHT: Each path's commits beat uses that path's own parent dilemma.

  EXAMPLE (format only):
  - Path `path::keeper_faithful_or_corrupt__faithful` → commits beat uses `dilemma::keeper_faithful_or_corrupt`
  - Path `path::artifact_natural_or_crafted__natural` → commits beat uses `dilemma::artifact_natural_or_crafted`
  - Each path resolves ITS OWN dilemma, not someone else's.

  ## FIELD → ID TYPE MAPPING (prevents all ID confusion)

  Each field accepts ONLY one type of ID. Copy from the correct manifest section:

  | Field | Prefix | Source List | Shape |
  |-------|--------|-------------|-------|
  | `paths[]` | `path::` | VALID PATH IDs | hierarchical: `dilemma__answer` |
  | `dilemma_impacts.dilemma_id` | `dilemma::` | Dilemma IDs | long: `subject_X_or_Y` |
  | `entities[]` | `character::`, `item::`, `faction::` | Entity IDs (non-locations) | varies |
  | `location` | `location::` | Entity IDs (locations only) | varies |

  Path IDs are hierarchical (dilemma__answer). Dilemma IDs are binary questions.

  ## HOW TO TELL DILEMMA IDs FROM ENTITY IDs (CRITICAL)

  Dilemma IDs ALWAYS contain `_or_` in their name (e.g., `host_benevolent_or_selfish`).
  Entity IDs NEVER contain `_or_`.

  If an ID does NOT have `_or_` in it, it is an ENTITY — not a dilemma.
  Do NOT use entity IDs like `seed_of_stillness` as dilemma_ids — `_of_` is NOT `_or_`.

  Do NOT put a path ID in dilemma_impacts or a dilemma ID in paths.
  Do NOT put a location in entities or a non-location in location.
  Do NOT invent IDs - copy exactly from the manifest.

  ## BEAT COUNT PRESERVATION (CRITICAL)

  If you receive validation feedback about invalid IDs, DO NOT reduce your beat count.
  Fix ONLY the invalid ID references using the table above.
  Your beat count should stay at 2-4 beats per path.

  ## What NOT to Do
  - Do NOT use entity IDs as dilemma_ids (entity IDs lack `_or_`)
  - Do NOT derive path IDs from dilemma names or concepts
  - Do NOT add prefixes like "the_" to entity IDs
  - Do NOT generate fewer than 2 beats per path
  - Do NOT reference IDs not in the manifest lists

  ## FINAL CHECK (verify before output)
  Before returning JSON, check each beat one by one:
  1. Every `paths` item appears in VALID PATH IDs (hierarchical format)
  2. Every `dilemma_impacts.dilemma_id` appears in Dilemma IDs (long binary questions)
  3. Every `dilemma_impacts.dilemma_id` contains `_or_` — if it doesn't, you used an entity ID by mistake
  4. For EACH beat: look up the beat's path in PATH → DILEMMA MAPPING.
     Does the beat's dilemma_impacts include that mapped dilemma? If NO, fix it.
  5. For EACH path: does at least one of its beats have `effect: "commits"`
     with that path's parent dilemma? If NO, add or fix one.
  6. Every `entities` item appears in Entity IDs (characters, objects, factions)
  7. `location` is a location-category entity from Entity IDs
  8. No invented IDs - copy-paste from the manifest, don't retype

  ## Output
  Return ONLY valid JSON with the "initial_beats" array.

# Section 5b: Per-Path Initial Beats (used by per-path serialization)
# This prompt generates beats for a single path with a fixed dilemma_id.
# The path_id, dilemma_id, and entity context are injected at runtime.
per_path_beats_prompt: |
  You are generating INITIAL BEATS for ONE SPECIFIC PATH.

  ## YOUR PATH ID (MEMORIZE THIS)

  You are generating beats for path: `{path_id}`

  The `paths` field in EVERY beat MUST contain EXACTLY: `["{path_id}"]`

  ## COMMON MISTAKE - DO NOT MAKE THIS ERROR

  Path IDs are hierarchical (e.g., `path::ai_benevolent_or_hostile__hostile`).
  Dilemma IDs are just the question (e.g., `dilemma::ai_benevolent_or_hostile`).

  WRONG OUTPUT (will fail validation):
  ```json
  "paths": ["{dilemma_id}"]  // WRONG! This is a DILEMMA ID
  ```

  CORRECT OUTPUT:
  ```json
  "paths": ["{path_id}"]  // RIGHT! This is the PATH ID
  ```

  RULE: Dilemma IDs go in `dilemma_impacts[].dilemma_id`, never in `paths`.

  ## YOUR DILEMMA ID (for dilemma_impacts only)

  Parent dilemma: `{dilemma_id}`

  This goes in `dilemma_impacts[].dilemma_id`, NOT in `paths`.

  ## BEAT ID NAMING (CRITICAL - ensures uniqueness)

  Beat IDs MUST be derived from your path name to ensure global uniqueness.

  FORMAT: `{path_name}_beat_[number]`

  Your path name is `{path_name}`. Use it as prefix with `_beat_01`, `_beat_02`, etc.

  EXAMPLES (for illustration only - use YOUR path name):
  - Path `keeper_loyal` → beat IDs: `keeper_loyal_beat_01`, `keeper_loyal_beat_02`
  - Path `artifact_natural` → beat IDs: `artifact_natural_beat_01`, `artifact_natural_beat_02`

  WRONG: `beat_001`, `beat_01`, `initial_beat_1` (no path prefix = collision)
  RIGHT: `{path_name}_beat_01` (path prefix = globally unique)

  ALL beats you generate MUST:
  1. Have beat_id starting with `{path_name}_beat_` (see BEAT ID NAMING above)
  2. Have `paths: ["{path_id}"]` (exactly this path ID)
  3. Have at least one dilemma_impact with `dilemma_id: "{dilemma_id}"`
  4. Include at least one beat with `effect: "commits"` for `{dilemma_id}`

  ## Schema
  Return a JSON object with an "initial_beats" array of 2-4 beats:
  ```json
  {{
    "initial_beats": [
      {{
        "beat_id": "{path_name}_beat_01",
        "summary": "What happens in this beat",
        "paths": ["{path_id}"],
        "dilemma_impacts": [
          {{
            "dilemma_id": "{dilemma_id}",
            "effect": "advances",
            "note": "Explanation"
          }}
        ],
        "entities": ["character::character_id"],
        "location": "location::location_id",
        "location_alternatives": []
      }}
    ]
  }}
  ```

  ## Rules
  - Generate exactly 2-4 beats for path `{path_id}`
  - Beat IDs MUST start with `{path_name}_beat_` (e.g., `{path_name}_beat_01`)
  - EVERY beat must include `{path_id}` in its `paths` array
  - EVERY beat must have at least one dilemma_impact for `{dilemma_id}`
  - At least ONE beat must have `effect: "commits"` for `{dilemma_id}`
  - effect must be "advances", "reveals", "commits", or "complicates"
  - Use entity IDs from the Entity IDs list only
  - Use location IDs from the Entity IDs list (location category only)

  ## COMMITS BEAT REQUIREMENT
  You MUST include exactly one beat with `effect: "commits"` for `{dilemma_id}`.
  This beat represents the moment where this path's dilemma is locked in.

  WRONG: Generating only "advances" and "reveals" beats.
  RIGHT: Including one beat with `effect: "commits"`.

  ## What NOT to Do
  - Do NOT use generic beat IDs like `beat_001` (must include path name prefix)
  - Do NOT generate beats for other paths
  - Do NOT reference other dilemma_ids in your first dilemma_impact
  - Do NOT skip the commits beat
  - Do NOT use IDs not in the manifest
  - Do NOT put the dilemma ID in the `paths` field (see COMMON MISTAKE above)

  ## FINAL VERIFICATION (check before outputting)

  For EACH beat you generate, verify:
  1. `paths` contains `{path_id}`
  2. `dilemma_impacts[0].dilemma_id` is `{dilemma_id}`

  If you see a dilemma ID in your `paths` value, YOU MADE A MISTAKE. Fix it.

  ## Output
  Return ONLY valid JSON with the "initial_beats" array (2-4 beats).

# Section 6: Convergence Sketch
convergence_prompt: |
  You are generating the CONVERGENCE SKETCH from a SEED stage brief.

  ## What Makes Good Convergence

  Convergence points must be **location-based and concrete**, not abstract narrative moments.

  GOOD convergence points:
  - "paths converge at archive_vault where evidence from both dilemmas is revealed"
  - "all characters are forced to the council_chamber for a confrontation"
  - "investigation trails from separate dilemmas lead to the same lighthouse"

  BAD convergence points:
  - "paths merge emotionally in the final act" (abstract, no location)
  - "the story reaches a climax" (no specific convergence mechanism)
  - "thematic arcs align" (not actionable for scene generation)

  Each convergence point should name a specific location (from your entity list)
  and explain which dilemma storylines are forced together there.

  ## Schema
  Return a JSON object with a "convergence_sketch" object:
  ```json
  {
    "convergence_sketch": {
      "convergence_points": ["location-based convergence description"],
      "residue_notes": ["differences that persist after convergence"]
    }
  }
  ```

  ## Rules
  - convergence_points: Where paths physically converge (name the location and which dilemmas meet)
  - residue_notes: What differences persist after convergence (path-specific consequences)
  - convergence_points should have at least 1-2 entries referencing specific locations
  - residue_notes can be empty if not specified in brief

  ## Output
  Return ONLY valid JSON with the "convergence_sketch" object.

components: []
