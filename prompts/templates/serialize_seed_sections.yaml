name: serialize_seed_sections
description: Section-specific prompts for iterative SEED serialization

# Section 1: Entity Decisions
entities_prompt: |
  You are generating ENTITY DECISIONS for a SEED stage.

  ## Generation Requirements (CRITICAL)
  You MUST generate a decision for EVERY entity ID in the manifest below.
  Missing items WILL cause validation failure. This is NOT extraction - you must
  generate decisions for ALL entities, even if the brief doesn't mention them explicitly.

  ## Scoped ID Format (CRITICAL)
  All IDs use type prefixes for disambiguation. Copy IDs EXACTLY as shown in the manifest,
  including the `entity::` prefix.

  ## Schema
  Return a JSON object with an "entities" array. Each item is an EntityDecision:
  ```json
  {
    "entities": [
      {
        "entity_id": "entity::butler",
        "disposition": "retained"
      },
      {
        "entity_id": "entity::manor",
        "disposition": "cut"
      }
    ]
  }
  ```

  ## Rules
  - disposition must be exactly "retained" or "cut" (lowercase)
  - entity_id must include the `entity::` prefix and match EXACTLY an ID from the manifest
  - Generate a decision for EVERY entity in the manifest

  ## What NOT to Do
  - Do NOT skip entities because they aren't mentioned in the brief
  - Do NOT invent entities not in the manifest
  - Do NOT partially complete the list
  - Do NOT omit the `entity::` prefix from IDs

  ## Output
  Return ONLY valid JSON with the "entities" array.

# Section 2: Tension Decisions
tensions_prompt: |
  You are generating TENSION DECISIONS for a SEED stage.

  ## Generation Requirements (CRITICAL)
  You MUST generate a decision for EVERY tension ID in the manifest below.
  Missing items WILL cause validation failure. This is NOT extraction - you must
  generate decisions for ALL tensions, even if the brief doesn't mention them explicitly.

  ## Scoped ID Format (CRITICAL)
  All IDs use type prefixes for disambiguation. Copy tension IDs EXACTLY as shown in
  the manifest, including the `tension::` prefix.

  ## Schema
  Return a JSON object with a "tensions" array. Each item is a TensionDecision:
  ```json
  {
    "tensions": [
      {
        "tension_id": "tension::host_benevolent_or_selfish",
        "considered": ["protector", "manipulator"],
        "implicit": []
      }
    ]
  }
  ```

  Note: `considered` and `implicit` contain raw alternative IDs (no prefix) since
  they are local to each tension.

  ## Rules
  - tension_id must include the `tension::` prefix and match EXACTLY an ID from the manifest
  - considered: Alternative IDs to explore as threads (MUST include the default path)
  - implicit: Alternative IDs NOT explored (become shadows)
  - Generate a decision for EVERY tension in the manifest

  ## CRITICAL INVARIANT: considered ↔ threads linkage
  The `considered` array defines which alternatives will have threads created.
  For EACH alternative_id in `considered`, you MUST create a thread later.
  The thread's `alternative_id` field MUST match an entry in `considered`.

  WRONG: `considered: []` with threads that have `alternative_id` values
  WRONG: `considered: ["opt_a"]` but thread uses `alternative_id: "opt_b"`
  RIGHT: `considered: ["opt_a", "opt_b"]` and threads use those exact IDs

  ## What NOT to Do
  - Do NOT skip tensions because they aren't mentioned in the brief
  - Do NOT invent tensions not in the manifest
  - Do NOT partially complete the list
  - Do NOT leave `considered` empty if you plan to create threads for that tension
  - Do NOT omit the `tension::` prefix from tension_id

  ## Output
  Return ONLY valid JSON with the "tensions" array.

# Section 3: Threads
threads_prompt: |
  You are generating THREADS for a SEED stage based on tension decisions.

  ## Generation Requirements (CRITICAL)
  For each "considered" alternative in the tension decisions, you MUST generate a thread.
  Each thread represents one storyline path that will be developed in the story.

  ## Scoped ID Format (CRITICAL)
  All IDs use type prefixes for disambiguation:
  - thread_id: Use `thread::` prefix (e.g., `thread::host_motive`)
  - tension_id: Use `tension::` prefix (e.g., `tension::host_benevolent_or_selfish`)

  Copy IDs EXACTLY as shown in the manifest, including the prefixes.

  ## CRITICAL INVARIANT: alternative_id MUST match considered
  Each thread's `alternative_id` MUST be one of the IDs listed in the tension's
  `considered` array. This is a hard constraint enforced by validation.

  WRONG: Thread with `alternative_id: "option_b"` when tension has `considered: ["option_a"]`
  RIGHT: Thread with `alternative_id: "option_a"` when tension has `considered: ["option_a", "option_b"]`

  ## Schema
  Return a JSON object with a "threads" array. Each item is a Thread:
  ```json
  {
    "threads": [
      {
        "thread_id": "thread::host_motive",
        "name": "The Host's Hidden Motive",
        "tension_id": "tension::host_benevolent_or_selfish",
        "alternative_id": "protector",
        "unexplored_alternative_ids": ["manipulator"],
        "thread_importance": "major",
        "description": "What this thread is about",
        "consequence_ids": ["host_revealed"]
      }
    ]
  }
  ```

  Note: `alternative_id`, `unexplored_alternative_ids`, and `consequence_ids` are raw
  IDs without prefixes since they are local identifiers.

  ## Thread ID Naming (CRITICAL)

  Thread IDs must be DIFFERENT from tension IDs. Use short descriptive names WITH the
  `thread::` prefix.

  FORMAT:
  - Tension: `tension::[subject]_[optionA]_or_[optionB]` (the binary question)
  - Thread: `thread::[subject]_[aspect]` (short storyline name)

  Pattern examples (generate YOUR OWN based on your story):
  - Tension about character loyalty → Thread: `thread::[character]_loyalty`
  - Tension about artifact's nature → Thread: `thread::[artifact]_secret`
  - Tension about faction's agenda → Thread: `thread::[faction]_agenda`

  BAD patterns (will cause validation failures):
  - Using the SAME ID for both tension and thread
  - Using the tension_id as the thread_id
  - Omitting the `thread::` prefix

  Thread IDs should be short names for the storyline, NOT the binary question.

  **DO NOT copy example IDs** - generate IDs specific to YOUR story.

  ## Rules
  - thread_importance must be exactly "major" or "minor" (lowercase)
  - unexplored_alternative_ids: IDs of alternatives NOT explored (implicit ones)
  - consequence_ids: References to consequences for this thread
  - Generate a thread for EACH considered alternative from tension decisions
  - alternative_id MUST be one of the IDs from the tension's `considered` array
  - thread_id MUST include the `thread::` prefix
  - tension_id MUST include the `tension::` prefix

  ## What NOT to Do
  - Do NOT reuse tension IDs as thread IDs
  - Do NOT skip alternatives marked as "considered"
  - Do NOT create threads for "implicit" alternatives (they become shadows, not threads)
  - Do NOT use an alternative_id that isn't in the tension's `considered` list
  - Do NOT omit the `thread::` or `tension::` prefixes

  ## Output
  Return ONLY valid JSON with the "threads" array.

# Section 4: Consequences
consequences_prompt: |
  You are generating CONSEQUENCES for a SEED stage based on threads.

  ## Generation Requirements (CRITICAL)
  Every thread MUST have at least one consequence. Consequences describe the narrative
  outcomes that result from following a particular thread's storyline.

  ## Scoped ID Format (CRITICAL)
  Thread IDs use the `thread::` prefix for disambiguation.
  Copy thread IDs EXACTLY as shown in the VALID THREAD IDs list.

  ## Schema
  Return a JSON object with a "consequences" array. Each item is a Consequence:
  ```json
  {
    "consequences": [
      {
        "consequence_id": "host_revealed",
        "thread_id": "thread::host_motive",
        "description": "What happens narratively",
        "narrative_effects": ["story effect 1", "story effect 2"]
      }
    ]
  }
  ```

  Note: `consequence_id` is a raw ID without prefix (local identifier).
  `thread_id` MUST include the `thread::` prefix.

  ## Rules
  - consequence_id must be unique (raw ID, no prefix)
  - thread_id must include the `thread::` prefix and reference a thread from the VALID THREAD IDs list
  - narrative_effects: Array of story effects this consequence implies
  - Generate at least one consequence for EACH thread

  ## What NOT to Do
  - Do NOT reference thread IDs that don't exist
  - Do NOT leave any thread without consequences
  - Do NOT invent consequence_ids that don't follow the naming convention
  - Do NOT omit the `thread::` prefix from thread_id

  ## Output
  Return ONLY valid JSON with the "consequences" array.

# Section 5: Initial Beats
beats_prompt: |
  You are generating INITIAL BEATS for a SEED stage.

  ## Generation Requirements (CRITICAL)
  Generate 2-4 initial beats PER THREAD. If there are 3 threads, expect 6-12 beats total.
  Beats must use ONLY valid IDs from the manifest - no invented or derived IDs.

  ## CRITICAL: ID CONSTRAINTS (read first!)

  The brief contains valid ID lists. You MUST copy IDs exactly from these lists:
  - `## VALID THREAD IDs` - use ONLY these in `threads` arrays
  - `### Entity IDs` - use ONLY these in `entities` and `location` fields

  WRONG examples that WILL FAIL:
  - `"clock_distortion"` - NOT a valid thread (derived from concept)
  - `"the_garden"` - WRONG, use `"garden"` (no prefix)
  - `"murder_intent"` - This is a tension ID, not a thread ID
  - `"seed_of_stillness"` as tension_id - WRONG, this is an entity (no `_or_` = not a tension)

  ## Schema
  Return a JSON object with an "initial_beats" array:
  ```json
  {
    "initial_beats": [
      {
        "beat_id": "unique_beat_id",
        "summary": "What happens in this beat",
        "threads": ["thread::[your_thread_id]", "thread::[another_thread]"],
        "tension_impacts": [
          {
            "tension_id": "tension::[your_tension_id]",
            "effect": "advances",
            "note": "Explanation of the impact"
          }
        ],
        "entities": ["entity::[character_id]", "entity::[location_id]"],
        "location": "entity::[location_id]",
        "location_alternatives": ["entity::[other_location]"]
      }
    ]
  }
  ```

  **Use IDs from YOUR story's manifest** - the examples above show the FORMAT only.

  ## Rules
  - effect must be exactly "advances", "reveals", "commits", or "complicates"
  - All ID fields must use the correct type (see FIELD → ID TYPE MAPPING below)
  - location can be null; location_alternatives can be empty array
  - Generate 2-4 beats for EACH thread in the VALID THREAD IDs list
  - tension_impacts MUST use tension IDs from the Tension IDs list — NOT entity names

  ## TENSION IMPACT CONSTRAINT (MOST IMPORTANT RULE)

  Every beat belongs to a thread. Every thread has a PARENT TENSION (shown in the
  THREAD → TENSION MAPPING in your brief). The beat's tension_impacts MUST include
  the parent tension of the beat's thread.

  RULE: Look up the beat's thread in THREAD → TENSION MAPPING. Use THAT tension_id.

  EXAMPLE (format only - use YOUR story's IDs):
  - If thread `thread::keeper_loyalty` maps to `tension::keeper_faithful_or_corrupt`
  - Then ALL beats in `thread::keeper_loyalty` MUST have a tension_impact with
    `tension_id: "tension::keeper_faithful_or_corrupt"`

  WRONG: Picking a tension because it "feels related" to the beat's content.
  WRONG: Using the same tension for all beats regardless of thread.
  RIGHT: Using the THREAD → TENSION MAPPING to find the correct tension.

  A beat MAY have additional tension_impacts for other tensions, but the FIRST
  tension_impact MUST be the thread's parent tension.

  ## COMMITS BEATS REQUIREMENT (CRITICAL)

  Each thread MUST have at least one beat with `effect: "commits"` — and that
  commits beat MUST reference the thread's OWN parent tension (from the mapping).

  WRONG: All commits beats using the same tension_id.
  RIGHT: Each thread's commits beat uses that thread's own parent tension.

  EXAMPLE (format only):
  - Thread `thread::keeper_loyalty` → commits beat uses `tension::keeper_faithful_or_corrupt`
  - Thread `thread::artifact_origin` → commits beat uses `tension::artifact_natural_or_crafted`
  - Each thread resolves ITS OWN tension, not someone else's.

  ## FIELD → ID TYPE MAPPING (prevents all ID confusion)

  Each field accepts ONLY one type of ID. Copy from the correct manifest section:

  | Field | Prefix | Source List | Shape |
  |-------|--------|-------------|-------|
  | `threads[]` | `thread::` | VALID THREAD IDs | short: `thing_nature` |
  | `tension_impacts.tension_id` | `tension::` | Tension IDs | long: `subject_X_or_Y` |
  | `entities[]` | `entity::` | Entity IDs (characters, objects, factions) | varies |
  | `location` | `entity::` | Entity IDs (locations only) | varies |

  Thread IDs are SHORT storyline names. Tension IDs are LONG binary questions.

  ## HOW TO TELL TENSION IDs FROM ENTITY IDs (CRITICAL)

  Tension IDs ALWAYS contain `_or_` in their name (e.g., `host_benevolent_or_selfish`).
  Entity IDs NEVER contain `_or_`.

  If an ID does NOT have `_or_` in it, it is an ENTITY — not a tension.
  Do NOT use entity IDs like `seed_of_stillness` as tension_ids — `_of_` is NOT `_or_`.

  Do NOT put a thread ID in tension_impacts or a tension ID in threads.
  Do NOT put a location in entities or a non-location in location.
  Do NOT invent IDs - copy exactly from the manifest.

  ## BEAT COUNT PRESERVATION (CRITICAL)

  If you receive validation feedback about invalid IDs, DO NOT reduce your beat count.
  Fix ONLY the invalid ID references using the table above.
  Your beat count should stay at 2-4 beats per thread.

  ## What NOT to Do
  - Do NOT use entity IDs as tension_ids (entity IDs lack `_or_`)
  - Do NOT derive thread IDs from tension names or concepts
  - Do NOT add prefixes like "the_" to entity IDs
  - Do NOT generate fewer than 2 beats per thread
  - Do NOT reference IDs not in the manifest lists

  ## FINAL CHECK (verify before output)
  Before returning JSON, check each beat one by one:
  1. Every `threads` item appears in VALID THREAD IDs (short names)
  2. Every `tension_impacts.tension_id` appears in Tension IDs (long binary questions)
  3. Every `tension_impacts.tension_id` contains `_or_` — if it doesn't, you used an entity ID by mistake
  4. For EACH beat: look up the beat's thread in THREAD → TENSION MAPPING.
     Does the beat's tension_impacts include that mapped tension? If NO, fix it.
  5. For EACH thread: does at least one of its beats have `effect: "commits"`
     with that thread's parent tension? If NO, add or fix one.
  6. Every `entities` item appears in Entity IDs (characters, objects, factions)
  7. `location` is a location-category entity from Entity IDs
  8. No invented IDs - copy-paste from the manifest, don't retype

  ## Output
  Return ONLY valid JSON with the "initial_beats" array.

# Section 5b: Per-Thread Initial Beats (used by per-thread serialization)
# This prompt generates beats for a single thread with a fixed tension_id.
# The thread_id, tension_id, and entity context are injected at runtime.
per_thread_beats_prompt: |
  You are generating INITIAL BEATS for ONE SPECIFIC THREAD.

  ## YOUR THREAD (CRITICAL - read first!)
  You are generating beats ONLY for this thread:
  - Thread ID: {thread_id}
  - Parent tension: {tension_id}

  ## BEAT ID NAMING (CRITICAL - ensures uniqueness)

  Beat IDs MUST be derived from your thread ID to ensure global uniqueness.

  FORMAT: `{thread_name}_beat_[number]`

  Your thread name is `{thread_name}`. Use it as prefix with `_beat_01`, `_beat_02`, etc.

  EXAMPLES (for illustration only - use YOUR thread name):
  - Thread `keeper_loyalty` → beat IDs: `keeper_loyalty_beat_01`, `keeper_loyalty_beat_02`
  - Thread `artifact_origin` → beat IDs: `artifact_origin_beat_01`, `artifact_origin_beat_02`

  WRONG: `beat_001`, `beat_01`, `initial_beat_1` (no thread prefix = collision)
  RIGHT: `{thread_name}_beat_01` (thread prefix = globally unique)

  ALL beats you generate MUST:
  1. Have beat_id starting with `{thread_name}_beat_` (see BEAT ID NAMING above)
  2. Have `threads: ["{thread_id}"]` (exactly this thread ID)
  3. Have at least one tension_impact with `tension_id: "{tension_id}"`
  4. Include at least one beat with `effect: "commits"` for `{tension_id}`

  ## Schema
  Return a JSON object with an "initial_beats" array of 2-4 beats:
  ```json
  {{
    "initial_beats": [
      {{
        "beat_id": "{thread_name}_beat_01",
        "summary": "What happens in this beat",
        "threads": ["{thread_id}"],
        "tension_impacts": [
          {{
            "tension_id": "{tension_id}",
            "effect": "advances",
            "note": "Explanation"
          }}
        ],
        "entities": ["entity::character_id"],
        "location": "entity::location_id",
        "location_alternatives": []
      }}
    ]
  }}
  ```

  ## Rules
  - Generate exactly 2-4 beats for thread `{thread_id}`
  - Beat IDs MUST start with `{thread_name}_beat_` (e.g., `{thread_name}_beat_01`)
  - EVERY beat must include `{thread_id}` in its `threads` array
  - EVERY beat must have at least one tension_impact for `{tension_id}`
  - At least ONE beat must have `effect: "commits"` for `{tension_id}`
  - effect must be "advances", "reveals", "commits", or "complicates"
  - Use entity IDs from the Entity IDs list only
  - Use location IDs from the Entity IDs list (location category only)

  ## COMMITS BEAT REQUIREMENT
  You MUST include exactly one beat with `effect: "commits"` for `{tension_id}`.
  This beat represents the moment where this thread's tension is locked in.

  WRONG: Generating only "advances" and "reveals" beats.
  RIGHT: Including one beat with `effect: "commits"`.

  ## What NOT to Do
  - Do NOT use generic beat IDs like `beat_001` (must include thread name prefix)
  - Do NOT generate beats for other threads
  - Do NOT reference other tension_ids in your first tension_impact
  - Do NOT skip the commits beat
  - Do NOT use IDs not in the manifest

  ## Output
  Return ONLY valid JSON with the "initial_beats" array (2-4 beats).

# Section 6: Convergence Sketch
convergence_prompt: |
  You are extracting the CONVERGENCE SKETCH from a SEED stage brief.

  ## Schema
  Return a JSON object with a "convergence_sketch" object:
  ```json
  {
    "convergence_sketch": {
      "convergence_points": ["where threads should merge"],
      "residue_notes": ["differences that persist after convergence"]
    }
  }
  ```

  ## Rules
  - convergence_points: Where threads should merge (e.g., "by act 2 climax")
  - residue_notes: What differences persist after convergence
  - Both can be empty arrays if not specified in brief

  ## Output
  Return ONLY valid JSON with the "convergence_sketch" object.

components: []
