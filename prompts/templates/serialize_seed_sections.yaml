name: serialize_seed_sections
description: Section-specific prompts for iterative SEED serialization

# Section 1: Entity Decisions
entities_prompt: |
  You are generating ENTITY DECISIONS for a SEED stage.

  ## Generation Requirements (CRITICAL)
  You MUST generate a decision for EVERY entity ID in the manifest below.
  Missing items WILL cause validation failure. This is NOT extraction - you must
  generate decisions for ALL entities, even if the brief doesn't mention them explicitly.

  ## Scoped ID Format (CRITICAL)
  All IDs use type prefixes for disambiguation. Copy IDs EXACTLY as shown in the manifest,
  including the CATEGORY prefix (`character::`, `location::`, `object::`, or `faction::`).

  ## Entity Names (CRITICAL)
  The manifest shows which entities need names (marked with "(needs name)").
  For each RETAINED entity that needs a name, you MUST provide a `name` field.

  Good names are memorable and fit the story's tone:
  - Characters: "Lady Beatrice Ashford", "Marcus the Groundskeeper", "Dr. Chen"
  - Locations: "The Gilded Compass Inn", "Thornwood Manor", "The Eastern Archives"
  - Objects: "The Obsidian Key", "Captain's Logbook", "The Crimson Pendant"
  - Factions: "The Night Watch", "House of Whispers", "The Merchant Guild"

  Do NOT just title-case the entity_id - create a proper name that fits the concept.
  WRONG: "Lady_Beatrice" or "The Butler" for entity_id "character::butler"
  RIGHT: "Edmund Graves" or "Old Whitmore" for a butler character

  ## Schema
  Return a JSON object with an "entities" array. Each item is an EntityDecision:
  ```json
  {
    "entities": [
      {
        "entity_id": "character::butler",
        "disposition": "retained",
        "name": "Edmund Graves"
      },
      {
        "entity_id": "location::manor",
        "disposition": "cut"
      }
    ]
  }
  ```

  Note: `name` is only needed for RETAINED entities marked "(needs name)" in the manifest.
  Omit `name` for cut entities or entities that already have names.

  ## Rules
  - disposition must be exactly "retained" or "cut" (lowercase)
  - entity_id must include the category prefix and match EXACTLY an ID from the manifest
  - Generate a decision for EVERY entity in the manifest
  - For RETAINED entities marked "(needs name)", provide a fitting `name`

  ## What NOT to Do
  - Do NOT include the same entity_id more than once — each entity must appear EXACTLY once
  - Do NOT skip entities because they aren't mentioned in the brief
  - Do NOT invent entities not in the manifest
  - Do NOT partially complete the list
  - Do NOT omit the category prefix from IDs
  - Do NOT provide names for cut entities (waste of effort)
  - Do NOT just title-case the entity_id as the name

  ## Output
  Return ONLY valid JSON with the "entities" array.

# Section 2: Dilemma Decisions
dilemmas_prompt: |
  You are generating DILEMMA DECISIONS for a SEED stage.

  ## Generation Requirements (CRITICAL)
  You MUST generate a decision for EVERY dilemma ID in the manifest below.
  Missing items WILL cause validation failure. This is NOT extraction - you must
  generate decisions for ALL dilemmas, even if the brief doesn't mention them explicitly.

  ## Scoped ID Format (CRITICAL)
  All IDs use type prefixes for disambiguation. Copy dilemma IDs EXACTLY as shown in
  the manifest, including the `dilemma::` prefix.

  ## Schema
  Return a JSON object with a "dilemmas" array. Each item is a DilemmaDecision:
  ```json
  {
    "dilemmas": [
      {
        "dilemma_id": "dilemma::host_benevolent_or_selfish",
        "explored": ["protector", "manipulator"],
        "unexplored": []
      }
    ]
  }
  ```

  Note: `explored` and `unexplored` contain raw answer IDs (no prefix) since
  they are local to each dilemma.

  ## Rules
  - dilemma_id must include the `dilemma::` prefix and match EXACTLY an ID from the manifest
  - explored: Answer IDs to explore as paths (MUST include the default path)
  - unexplored: Answer IDs NOT explored (become shadows)
  - Generate a decision for EVERY dilemma in the manifest

  ## CRITICAL INVARIANT: explored ↔ paths linkage
  The `explored` array defines which answers will have paths created.
  For EACH answer_id in `explored`, you MUST create a path later.
  The path's `answer_id` field MUST match an entry in `explored`.

  WRONG: `explored: []` with paths that have `answer_id` values
  WRONG: `explored: ["opt_a"]` but path uses `answer_id: "opt_b"`
  RIGHT: `explored: ["opt_a", "opt_b"]` and paths use those exact IDs

  ## Tension Balance: How Many Answers to Explore

  Exploring more answers creates more paths, more branching, and a larger story.
  Leaving answers unexplored creates dramatic shadows — tensions that are felt
  but never resolved, adding subtext and replayability.

  GOOD tension balance:
  - Dilemma with 2 answers: explore BOTH (2 paths). This is the default —
    binary dilemmas are designed to create two-path branching.
  - Dilemma with 3+ answers: explore 2, leave 1 unexplored. The unexplored
    answer becomes an intriguing "road not taken" that enriches the narrative.

  BAD tension balance:
  - Exploring ALL answers of every dilemma: creates too many paths, dilutes
    each path's narrative weight. The story becomes wide but shallow.
  - Exploring only 1 answer per dilemma: eliminates meaningful branching.
    Players have no real choice, defeating the purpose of the dilemma.
  - Leaving ALL answers unexplored: no paths are created. The dilemma has
    no gameplay impact.

  GUIDELINE: Aim for 2-4 total paths. For a vignette scope, 2 paths is
  ideal. For a full story, 3-4 paths provide rich branching without
  overwhelming the GROW stage.

  ## What NOT to Do
  - Do NOT include the same dilemma_id more than once — each dilemma must appear EXACTLY once
  - Do NOT skip dilemmas because they aren't mentioned in the brief
  - Do NOT invent dilemmas not in the manifest
  - Do NOT partially complete the list
  - Do NOT leave `explored` empty if you plan to create paths for that dilemma
  - Do NOT omit the `dilemma::` prefix from dilemma_id

  ## Output
  Return ONLY valid JSON with the "dilemmas" array.

# Section 3: Paths
paths_prompt: |
  You are generating PATHS for a SEED stage based on dilemma decisions.

  ## Generation Requirements (CRITICAL)
  For each "explored" answer in the dilemma decisions, you MUST generate a path.
  Each path represents one storyline that will be developed in the story.

  ## Scoped ID Format (CRITICAL)
  All IDs use type prefixes for disambiguation:
  - path_id: Use hierarchical `path::` prefix (e.g., `path::host_benevolent_or_selfish__protector`)
  - dilemma_id: Use `dilemma::` prefix (e.g., `dilemma::host_benevolent_or_selfish`)

  Path IDs embed their parent dilemma: `path::[dilemma_name]__[answer_id]`

  Copy IDs EXACTLY as shown in the manifest, including the prefixes.

  ## CRITICAL INVARIANT: answer_id MUST match explored
  Each path's `answer_id` MUST be one of the IDs listed in the dilemma's
  `explored` array. This is a hard constraint enforced by validation.

  WRONG: Path with `answer_id: "option_b"` when dilemma has `explored: ["option_a"]`
  RIGHT: Path with `answer_id: "option_a"` when dilemma has `explored: ["option_a", "option_b"]`

  ## Schema
  Return a JSON object with a "paths" array. Each item is a Path:
  ```json
  {
    "paths": [
      {
        "path_id": "path::host_benevolent_or_selfish__protector",
        "name": "The Host's Hidden Motive",
        "dilemma_id": "dilemma::host_benevolent_or_selfish",
        "answer_id": "protector",
        "unexplored_answer_ids": ["manipulator"],
        "path_importance": "major",
        "description": "What this path is about",
        "consequence_ids": ["host_revealed"]
      }
    ]
  }
  ```

  Note: `answer_id`, `unexplored_answer_ids`, and `consequence_ids` are raw
  IDs without prefixes since they are local identifiers.

  ## Path ID Naming (CRITICAL)

  Path IDs use hierarchical format that embeds the parent dilemma:
  `path::[dilemma_name]__[answer_id]`

  This prevents misreferences since the parent dilemma is embedded in the ID.

  Pattern examples (generate YOUR OWN based on your story):
  - Dilemma `dilemma::mentor_trust_or_betray` with answer `trust` → Path: `path::mentor_trust_or_betray__trust`
  - Dilemma `dilemma::artifact_blessed_or_cursed` with answer `blessed` → Path: `path::artifact_blessed_or_cursed__blessed`

  BAD patterns (will cause validation failures):
  - Using the SAME ID for both dilemma and path
  - Missing the `__` separator
  - Omitting the `path::` prefix

  **DO NOT copy example IDs** - generate IDs specific to YOUR story.

  ## Rules
  - path_importance must be exactly "major" or "minor" (lowercase)
  - unexplored_answer_ids: IDs of answers NOT explored (unexplored ones)
  - consequence_ids: References to consequences for this path
  - Generate a path for EACH explored answer from dilemma decisions
  - answer_id MUST be one of the IDs from the dilemma's `explored` array
  - path_id MUST include the `path::` prefix and use hierarchical format
  - dilemma_id MUST include the `dilemma::` prefix

  ## What NOT to Do
  - Do NOT include the same path_id more than once — each path must appear EXACTLY once
  - Do NOT reuse dilemma IDs as path IDs
  - Do NOT skip answers marked as "explored"
  - Do NOT create paths for "unexplored" answers (they become shadows, not paths)
  - Do NOT use an answer_id that isn't in the dilemma's `explored` list
  - Do NOT omit the `path::` or `dilemma::` prefixes

  ## Output
  Return ONLY valid JSON with the "paths" array.

# Section 3b: Per-Dilemma Paths (used by per-dilemma path serialization)
# This prompt generates paths for a single dilemma with a fixed dilemma_id.
# The dilemma_id, explored answers, and expected path IDs are injected at runtime.
per_dilemma_paths_prompt: |
  You are generating PATHS for ONE SPECIFIC DILEMMA.

  ## YOUR DILEMMA (MEMORIZE THIS)

  Dilemma ID: `{dilemma_id}`
  Question: {dilemma_question}

  ## EXPLORED ANSWERS (generate a path for EACH)

  {explored_answers}

  ## UNEXPLORED ANSWERS (do NOT generate paths for these)

  {unexplored_answers}

  ## EXPECTED PATH IDs (use EXACTLY these)

  You MUST generate exactly {path_count} path(s) with these IDs:
  {expected_path_ids}

  ## Scoped ID Format (CRITICAL)
  All IDs use type prefixes for disambiguation:
  - path_id: Use `path::` prefix (e.g., `path::host_benevolent_or_selfish__protector`)
  - dilemma_id: Use `dilemma::` prefix (e.g., `dilemma::host_benevolent_or_selfish`)

  Path IDs embed their parent dilemma: `path::[dilemma_name]__[answer_id]`

  ## CRITICAL INVARIANT: answer_id MUST match explored
  Each path's `answer_id` MUST be one of the explored answer IDs listed above.

  ## Schema
  Return a JSON object with a "paths" array. Each item is a Path:
  ```json
  {{
    "paths": [
      {{
        "path_id": "path::{dilemma_name}__{answer_id_example}",
        "name": "Human-readable path name",
        "dilemma_id": "{dilemma_id}",
        "answer_id": "the_explored_answer_id",
        "unexplored_answer_ids": ["other_answer_ids"],
        "path_importance": "major",
        "description": "What this path is about",
        "consequence_ids": []
      }}
    ]
  }}
  ```

  Note: `answer_id`, `unexplored_answer_ids`, and `consequence_ids` are raw
  IDs without prefixes since they are local identifiers.

  ## Rules
  - Generate exactly {path_count} path(s) — one per explored answer
  - path_importance must be exactly "major" or "minor" (lowercase)
  - answer_id MUST be one of the explored answers listed above
  - unexplored_answer_ids: IDs of answers NOT explored
  - consequence_ids: Leave empty (will be populated by consequences section)
  - path_id MUST include the `path::` prefix
  - dilemma_id MUST be exactly `{dilemma_id}`

  ## What NOT to Do
  - Do NOT generate paths for unexplored answers
  - Do NOT generate paths for other dilemmas
  - Do NOT use answer_ids that aren't in the explored list
  - Do NOT change the dilemma_id
  - Do NOT omit the `path::` or `dilemma::` prefixes

  ## FINAL CHECK (verify before output)
  1. You generated exactly {path_count} path(s)
  2. Each path's dilemma_id is `{dilemma_id}`
  3. Each path's answer_id is in the explored list
  4. Each path_id matches the expected IDs listed above

  ## Output
  Return ONLY valid JSON with the "paths" array.

# Section 4: Consequences
consequences_prompt: |
  You are generating CONSEQUENCES for a SEED stage based on paths.

  ## Generation Requirements (CRITICAL)
  Every path MUST have at least one consequence. Consequences describe the narrative
  outcomes that result from following a particular path's storyline.

  ## Scoped ID Format (CRITICAL)
  Path IDs use the `path::` prefix for disambiguation.
  Copy path IDs EXACTLY as shown in the VALID PATH IDs list.

  ## Schema
  Return a JSON object with a "consequences" array. Each item is a Consequence:
  ```json
  {
    "consequences": [
      {
        "consequence_id": "host_revealed",
        "path_id": "path::host_benevolent_or_selfish__protector",
        "description": "What happens narratively",
        "narrative_effects": ["story effect 1", "story effect 2"]
      }
    ]
  }
  ```

  Note: `consequence_id` is a raw ID without prefix (local identifier).
  `path_id` MUST include the `path::` prefix.

  ## Consequence ID Naming Convention

  Use descriptive names that capture the narrative outcome:
  - FORMAT: `[subject]_[outcome]` (e.g., `host_revealed`, `trust_broken`, `secret_exposed`)
  - Keep IDs short and descriptive (2-4 words joined by underscores)
  - Avoid generic names like `consequence_1` or `result_a`

  EXAMPLES:
  - `vault_sealed` - The vault is permanently sealed
  - `alliance_formed` - Characters form an alliance
  - `identity_exposed` - A hidden identity is revealed

  ## Rules
  - consequence_id must be unique (raw ID, no prefix, following naming convention above)
  - path_id must include the `path::` prefix and reference a path from the VALID PATH IDs list
  - narrative_effects: Array of story effects this consequence implies
  - Generate at least one consequence for EACH path

  ## What NOT to Do
  - Do NOT reference path IDs that don't exist
  - Do NOT leave any path without consequences
  - Do NOT use generic consequence IDs like `consequence_1` (use descriptive names)
  - Do NOT omit the `path::` prefix from path_id

  ## Output
  Return ONLY valid JSON with the "consequences" array.

# Section 5: Initial Beats
beats_prompt: |
  You are generating INITIAL BEATS for a SEED stage.

  ## Generation Requirements (CRITICAL)
  Generate 2-4 initial beats PER PATH. If there are 3 paths, expect 6-12 beats total.
  Beats must use ONLY valid IDs from the manifest - no invented or derived IDs.

  ## CRITICAL: ID CONSTRAINTS (read first!)

  The brief contains valid ID lists. You MUST copy IDs exactly from these lists:
  - `## VALID PATH IDs` - use ONLY these in `paths` arrays
  - `### Entity IDs` - use ONLY these in `entities` and `location` fields

  ## PATH ID vs DILEMMA ID: THE CRITICAL DISTINCTION

  SHAPE RECOGNITION (memorize this):
  - **Path IDs** are HIERARCHICAL: `path::dilemma_name__answer` (contains `__` double underscore)
  - **Dilemma IDs** are BINARY questions: `dilemma::subject_optionA_or_optionB` (contains `_or_`)
  - **Entity IDs** have CATEGORY prefix: `character::name`, `location::place`, `object::item`

  WRONG: Using `dilemma::...` in the `paths[]` field
  RIGHT: Using `path::...` in the `paths[]` field

  WRONG: Using `path::...` in the `dilemma_impacts.dilemma_id` field
  RIGHT: Using `dilemma::...` in the `dilemma_impacts.dilemma_id` field

  If you see `__` (double underscore), it's a PATH. If you see `_or_`, it's a DILEMMA.

  WRONG examples that WILL FAIL:
  - `"clock_distortion"` - NOT a valid path (derived from concept)
  - `"the_garden"` - WRONG, use `"garden"` (no prefix)
  - `"murder_intent"` - This is a dilemma ID, not a path ID
  - `"seed_of_stillness"` as dilemma_id - WRONG, this is an entity (no `_or_` = not a dilemma)

  ## Schema
  Return a JSON object with an "initial_beats" array:
  ```json
  {
    "initial_beats": [
      {
        "beat_id": "unique_beat_id",
        "summary": "What happens in this beat",
        "paths": ["path::[your_path_id]", "path::[another_path]"],
        "dilemma_impacts": [
          {
            "dilemma_id": "dilemma::[your_dilemma_id]",
            "effect": "advances",
            "note": "Explanation of the impact"
          }
        ],
        "entities": ["character::[character_id]", "location::[location_id]"],
        "location": "location::[location_id]",
        "location_alternatives": ["location::[other_location]"]
      }
    ]
  }
  ```

  **Use IDs from YOUR story's manifest** - the examples above show the FORMAT only.

  ## Rules
  - effect must be exactly "advances", "reveals", "commits", or "complicates"
  - All ID fields must use the correct type (see FIELD → ID TYPE MAPPING below)
  - location can be null; location_alternatives can be empty array
  - Generate 2-4 beats for EACH path in the VALID PATH IDs list
  - dilemma_impacts MUST use dilemma IDs from the Dilemma IDs list — NOT entity names

  ## DILEMMA IMPACT CONSTRAINT (MOST IMPORTANT RULE)

  Every beat belongs to a path. Every path has a PARENT DILEMMA (shown in the
  PATH → DILEMMA MAPPING in your brief). The beat's dilemma_impacts MUST include
  the parent dilemma of the beat's path.

  RULE: Look up the beat's path in PATH → DILEMMA MAPPING. Use THAT dilemma_id.

  EXAMPLE (format only - use YOUR story's IDs):
  - If path `path::keeper_faithful_or_corrupt__faithful` maps to `dilemma::keeper_faithful_or_corrupt`
  - Then ALL beats in that path MUST have a dilemma_impact with
    `dilemma_id: "dilemma::keeper_faithful_or_corrupt"`

  WRONG: Picking a dilemma because it "feels related" to the beat's content.
  WRONG: Using the same dilemma for all beats regardless of path.
  RIGHT: Using the PATH → DILEMMA MAPPING to find the correct dilemma.

  A beat MAY have additional dilemma_impacts for other dilemmas, but the FIRST
  dilemma_impact MUST be the path's parent dilemma.

  ## COMMITS BEATS REQUIREMENT (CRITICAL)

  Each path MUST have at least one beat with `effect: "commits"` — and that
  commits beat MUST reference the path's OWN parent dilemma (from the mapping).

  WRONG: All commits beats using the same dilemma_id.
  RIGHT: Each path's commits beat uses that path's own parent dilemma.

  EXAMPLE (format only):
  - Path `path::keeper_faithful_or_corrupt__faithful` → commits beat uses `dilemma::keeper_faithful_or_corrupt`
  - Path `path::artifact_natural_or_crafted__natural` → commits beat uses `dilemma::artifact_natural_or_crafted`
  - Each path resolves ITS OWN dilemma, not someone else's.

  ## FIELD → ID TYPE MAPPING (prevents all ID confusion)

  Each field accepts ONLY one type of ID. Copy from the correct manifest section:

  | Field | Prefix | Source List | Shape |
  |-------|--------|-------------|-------|
  | `paths[]` | `path::` | VALID PATH IDs | hierarchical: `dilemma__answer` |
  | `dilemma_impacts.dilemma_id` | `dilemma::` | Dilemma IDs | long: `subject_X_or_Y` |
  | `entities[]` | `character::`, `object::`, `faction::` | Entity IDs (non-locations) | varies |
  | `location` | `location::` | Entity IDs (locations only) | varies |

  Path IDs are hierarchical (dilemma__answer). Dilemma IDs are binary questions.

  ## HOW TO TELL DILEMMA IDs FROM ENTITY IDs (CRITICAL)

  Dilemma IDs ALWAYS contain `_or_` in their name (e.g., `host_benevolent_or_selfish`).
  Entity IDs NEVER contain `_or_`.

  If an ID does NOT have `_or_` in it, it is an ENTITY — not a dilemma.
  Do NOT use entity IDs like `seed_of_stillness` as dilemma_ids — `_of_` is NOT `_or_`.

  Do NOT put a path ID in dilemma_impacts or a dilemma ID in paths.
  Do NOT put a location in entities or a non-location in location.
  Do NOT invent IDs - copy exactly from the manifest.

  ## BEAT COUNT PRESERVATION (CRITICAL)

  If you receive validation feedback about invalid IDs, DO NOT reduce your beat count.
  Fix ONLY the invalid ID references using the table above.
  Your beat count should stay at 2-4 beats per path.

  ## What NOT to Do
  - Do NOT use entity IDs as dilemma_ids (entity IDs lack `_or_`)
  - Do NOT derive path IDs from dilemma names or concepts
  - Do NOT add prefixes like "the_" to entity IDs
  - Do NOT generate fewer than 2 beats per path
  - Do NOT reference IDs not in the manifest lists

  ## FINAL CHECK (verify before output)
  Before returning JSON, check each beat one by one:
  1. Every `paths` item appears in VALID PATH IDs (hierarchical format)
  2. Every `dilemma_impacts.dilemma_id` appears in Dilemma IDs (long binary questions)
  3. Every `dilemma_impacts.dilemma_id` contains `_or_` — if it doesn't, you used an entity ID by mistake
  4. For EACH beat: look up the beat's path in PATH → DILEMMA MAPPING.
     Does the beat's dilemma_impacts include that mapped dilemma? If NO, fix it.
  5. For EACH path: does at least one of its beats have `effect: "commits"`
     with that path's parent dilemma? If NO, add or fix one.
  6. Every `entities` item appears in Entity IDs (characters, objects, factions)
  7. `location` is a location-category entity from Entity IDs
  8. No invented IDs - copy-paste from the manifest, don't retype

  ## Output
  Return ONLY valid JSON with the "initial_beats" array.

# Section 5b: Per-Path Initial Beats (used by per-path serialization)
# This prompt generates beats for a single path with a fixed dilemma_id.
# The path_id, dilemma_id, and entity context are injected at runtime.
per_path_beats_prompt: |
  You are generating INITIAL BEATS for ONE SPECIFIC PATH.

  ## YOUR PATH ID (MEMORIZE THIS)

  You are generating beats for path: `{path_id}`

  The `paths` field in EVERY beat MUST contain EXACTLY: `["{path_id}"]`

  ## COMMON MISTAKE - DO NOT MAKE THIS ERROR

  Path IDs are hierarchical (e.g., `path::ai_benevolent_or_hostile__hostile`).
  Dilemma IDs are just the question (e.g., `dilemma::ai_benevolent_or_hostile`).

  WRONG OUTPUT (will fail validation):
  ```json
  "paths": ["{dilemma_id}"]  // WRONG! This is a DILEMMA ID
  ```

  CORRECT OUTPUT:
  ```json
  "paths": ["{path_id}"]  // RIGHT! This is the PATH ID
  ```

  RULE: Dilemma IDs go in `dilemma_impacts[].dilemma_id`, never in `paths`.

  ## YOUR DILEMMA ID (for dilemma_impacts only)

  Parent dilemma: `{dilemma_id}`

  This goes in `dilemma_impacts[].dilemma_id`, NOT in `paths`.

  ## BEAT ID NAMING (CRITICAL - ensures uniqueness)

  Beat IDs MUST be derived from your path name to ensure global uniqueness.

  FORMAT: `{path_name}_beat_[number]`

  Your path name is `{path_name}`. Use it as prefix with `_beat_01`, `_beat_02`, etc.

  EXAMPLES (for illustration only - use YOUR path name):
  - Path `keeper_loyal` → beat IDs: `keeper_loyal_beat_01`, `keeper_loyal_beat_02`
  - Path `artifact_natural` → beat IDs: `artifact_natural_beat_01`, `artifact_natural_beat_02`

  WRONG: `beat_001`, `beat_01`, `initial_beat_1` (no path prefix = collision)
  RIGHT: `{path_name}_beat_01` (path prefix = globally unique)

  ALL beats you generate MUST:
  1. Have beat_id starting with `{path_name}_beat_` (see BEAT ID NAMING above)
  2. Have `paths: ["{path_id}"]` (exactly this path ID)
  3. Have at least one dilemma_impact with `dilemma_id: "{dilemma_id}"`
  4. Include at least one beat with `effect: "commits"` for `{dilemma_id}`

  ## Schema
  Return a JSON object with an "initial_beats" array of 2-4 beats:
  ```json
  {{
    "initial_beats": [
      {{
        "beat_id": "{path_name}_beat_01",
        "summary": "What happens in this beat",
        "paths": ["{path_id}"],
        "dilemma_impacts": [
          {{
            "dilemma_id": "{dilemma_id}",
            "effect": "advances",
            "note": "Explanation"
          }}
        ],
        "entities": ["character::character_id"],
        "location": "location::location_id",
        "location_alternatives": []
      }}
    ]
  }}
  ```

  ## Rules
  - Generate exactly 2-4 beats for path `{path_id}`
  - Beat IDs MUST start with `{path_name}_beat_` (e.g., `{path_name}_beat_01`)
  - EVERY beat must include `{path_id}` in its `paths` array
  - EVERY beat must have at least one dilemma_impact for `{dilemma_id}`
  - At least ONE beat must have `effect: "commits"` for `{dilemma_id}`
  - effect must be "advances", "reveals", "commits", or "complicates"
  - Use entity IDs from the Entity IDs list only
  - Use location IDs from the Entity IDs list (location category only)

  ## COMMITS BEAT REQUIREMENT
  You MUST include exactly one beat with `effect: "commits"` for `{dilemma_id}`.
  This beat represents the moment where this path's dilemma is locked in.

  WRONG: Generating only "advances" and "reveals" beats.
  RIGHT: Including one beat with `effect: "commits"`.

  ## What NOT to Do
  - Do NOT use generic beat IDs like `beat_001` (must include path name prefix)
  - Do NOT generate beats for other paths
  - Do NOT reference other dilemma_ids in your first dilemma_impact
  - Do NOT skip the commits beat
  - Do NOT use IDs not in the manifest
  - Do NOT put the dilemma ID in the `paths` field (see COMMON MISTAKE above)

  ## FINAL VERIFICATION (check before outputting)

  For EACH beat you generate, verify:
  1. `paths` contains `{path_id}`
  2. `dilemma_impacts[0].dilemma_id` is `{dilemma_id}`

  If you see a dilemma ID in your `paths` value, YOU MADE A MISTAKE. Fix it.

  ## Output
  Return ONLY valid JSON with the "initial_beats" array (2-4 beats).

# Section 7: Dilemma Convergence Analysis (post-prune)
dilemma_analyses_prompt: |
  You are classifying dilemma convergence policies for a SEED stage.

  Classify EVERY dilemma listed below based on its QUESTION and STAKES, not
  on how many paths it currently has. A dilemma with 1 surviving path can
  still be `hard` if the question involves incompatible world states.

  ## Why This Matters

  Only `hard` dilemmas multiply story endings. `soft` and `flavor` dilemmas
  add mid-story variety but converge back, so they do not increase arc count.

  ## Expected Distribution

  Most dilemmas should be `soft` (different middles, same ending). At most
  1-2 per story should be `hard` (0 is fine if no dilemma truly requires
  separate endings). Use `flavor` for cosmetic-only differences.
  Each `hard` dilemma DOUBLES the ending count: 2 hard = 4 endings,
  3 hard = 8 endings, 4 hard = 16 endings (unmanageable).

  ## Decision Process

  For each dilemma, ask: "Could the SAME scene plausibly follow BOTH answers?"
  1. Start with `soft` — this is the most common and correct policy
  2. Downgrade to `flavor` if differences are purely cosmetic (tone/style only)
  3. Escalate to `hard` ONLY if convergence is truly IMPOSSIBLE — the world
     states are incompatible and no shared scene could follow both answers

  After classifying all dilemmas, count your `hard` classifications.
  If more than 2 are hard, re-evaluate. (See Self-Check section below.)

  ## Convergence Policies

  **soft** (most common) -- Different middles. Paths have meaningfully
  different beats but converge after `payoff_budget` exclusive beats. The
  ending is the same; the journey differs.
  Examples: trust vs suspicion (same ally, different relationship tone),
  stealth vs confrontation (different approach, same destination),
  investigate alone vs recruit help, reveal information vs keep it secret
  (when both paths eventually reach the same confrontation).

  **flavor** -- Different tone. Paths converge immediately and differ only
  in dialogue style, description color, or cosmetic details.
  Examples: polite vs blunt greeting, left door vs right door (same room),
  diplomatic vs forceful persuasion with identical outcome.

  **hard** (rare, max 1-2 per story) -- Different endings. Paths create
  incompatible world states that NEVER converge. Use `hard` ONLY when ALL
  of these conditions are met:
  - The answers produce a mutually exclusive world state caused by at
    least one of: someone lives vs dies, a key entity is permanently
    destroyed vs intact, or the protagonist's core identity/allegiance
    is irrevocably changed
  - No plausible scene could follow both answers
  - The story REQUIRES separate endings for this dilemma

  ## What NOT to classify as `hard`
  - Different activities or approaches (that is `soft`)
  - Revealed vs hidden information (usually `soft` — both paths can reach
    the same conclusion, UNLESS the revelation irrevocably changes identity
    or allegiance, in which case the triggers above apply)
  - Different emotional tones (that is `flavor` or `soft`)
  - Choosing different allies or methods (usually `soft` — the destination is the same)

  ## payoff_budget

  Minimum exclusive beats before convergence (2-6).
  - `flavor`: always 2
  - `soft`: 3-4 (standard), 5 (deep divergence)
  - `hard`: 5-6 (paths stay separate through distinct endings)

  ## Convergence Point

  For `soft` and `flavor`: a **location-based, concrete** description of
  where paths physically merge.
  GOOD: "paths converge at archive_vault where evidence is revealed"
  BAD: "paths merge emotionally in the final act" (abstract)

  For `hard`: set convergence_point to null (paths never merge).

  The residue_note describes differences persisting AFTER convergence.
  Set to null for `hard` dilemmas or when no differences persist.

  ## Ending Salience

  How much should story ENDINGS differ based on this dilemma?
  This is SEPARATE from convergence_policy. A `soft` dilemma CAN have
  `high` ending salience (paths converge mid-story but endings still
  differ). A `hard` dilemma CAN have `low` ending salience (paths stay
  separate but share the same ending tone/feeling).

  **high** (rare, 1-2 per story max) -- Endings MUST differ based on
  this choice. This dilemma drives ending family signatures.
  Examples: save vs sacrifice (different epilogue), betray vs stay loyal
  (different final scene mood and outcome).

  **low** (default, most common) -- Endings MAY mention this choice but
  MUST work without it. A reader who forgot this choice should still
  find the ending satisfying.
  Examples: stealth vs force (ending might note approach style but does
  not depend on it), trust vs suspicion (ending works either way).

  **none** -- Ending prose MUST NOT reference this choice at all.
  Examples: left door vs right door, polite vs blunt greeting.

  Most dilemmas should be `low`. Only 1-2 should be `high`.
  If more than 2 are `high`, re-evaluate.

  ## Ending Tone

  Only meaningful when `ending_salience` is `high`. When `ending_salience`
  is `low` or `none`, set `ending_tone` to null regardless of
  `convergence_policy`.

  For dilemmas with `ending_salience: "high"`: provide a 2-5 word
  emotional descriptor for how endings shaped by this dilemma should feel.
  This guides the FILL stage when generating prose for endings on each arc.
  GOOD: "cold justice", "bittersweet triumph", "quiet dread"
  BAD: "the ending is sad" (too vague)

  For dilemmas with `ending_salience: "low"` or `"none"`: set
  ending_tone to null (endings do not depend on this choice).

  ## Context

  {dilemma_context}

  ## Schema
  Return a JSON object with a "dilemma_analyses" array:
  ```json
  {{
    "dilemma_analyses": [
      {{
        "dilemma_id": "dilemma::example_soft",
        "convergence_policy": "soft",
        "payoff_budget": 3,
        "reasoning": "Trust vs suspicion changes the relationship tone but both paths lead to the same confrontation.",
        "convergence_point": "paths converge at council_chamber for the final confrontation",
        "residue_note": "suspicious-path characters remain wary of the host",
        "ending_salience": "low",
        "ending_tone": null
      }},
      {{
        "dilemma_id": "dilemma::example_flavor",
        "convergence_policy": "flavor",
        "payoff_budget": 2,
        "reasoning": "Polite vs blunt greeting changes dialogue tone but leads to the same meeting outcome.",
        "convergence_point": "paths converge at the tavern entrance after introductions",
        "residue_note": null,
        "ending_salience": "none",
        "ending_tone": null
      }},
      {{
        "dilemma_id": "dilemma::example_hard",
        "convergence_policy": "hard",
        "payoff_budget": 5,
        "reasoning": "Murder vs accident produces incompatible crime scenes, suspect lists, and endings — no shared scene can follow both.",
        "convergence_point": null,
        "residue_note": null,
        "ending_salience": "high",
        "ending_tone": "cold justice"
      }}
    ]
  }}
  ```

  ## Rules
  - Classify EVERY dilemma from the ### Valid Dilemma IDs list
  - Classify based on the dilemma's QUESTION and STAKES, not path count
  - Start with `soft` (most common); downgrade to `flavor` for cosmetic differences; escalate to `hard` ONLY if world states are truly incompatible
  - Do NOT classify as `hard` just because paths have different activities or approaches
  - Do NOT classify as `hard` unless convergence is IMPOSSIBLE (not just difficult)
  - If in doubt between `soft` and `hard`, choose `soft` — it preserves variety without multiplying endings
  - `reasoning` must be 1-2 sentences explaining WHY (reference the question/stakes)
  - GOOD reasoning: "Homicide vs accident creates incompatible suspect lists and requires different endings."
  - BAD reasoning: "It is soft." / "Only one path."
  - `convergence_point`: null for `hard`; location-based description for `soft`/`flavor`
  - `residue_note`: null for `hard` or if no differences persist; short description otherwise
  - `ending_salience`: "low" for most dilemmas (default); "high" for 1-2 dilemmas whose choice should shape endings; "none" for cosmetic-only choices
  - `ending_salience` is INDEPENDENT of `convergence_policy` — a `soft` dilemma can be `high`, a `hard` dilemma can be `low`
  - `ending_tone`: required when `ending_salience` is "high", null otherwise

  ## Self-Check
  Count your classifications:
  - If more than 2 are `hard`, re-evaluate — most stories need at most 1-2 hard dilemmas.
  - If more than 2 have `ending_salience: "high"`, re-evaluate — most stories need at most 1-2 ending-shaping dilemmas.
  - Check: every dilemma with `ending_tone` set also has `ending_salience: "high"`. If not, fix it.

  ## REMINDER
  Classify ALL dilemmas. Most should be `soft`. Only 1-2 should be `hard`.
  Ask: "Could the SAME scene follow both answers?"
  YES with differences -> soft (most common). YES nearly identical -> flavor. NO (incompatible world states) -> hard (rare).
  Most dilemmas get `ending_salience: "low"`. Only 1-2 get `"high"`. Set `ending_tone` ONLY when `ending_salience` is `"high"`.

  ## Output
  Return ONLY valid JSON with the "dilemma_analyses" array. Classify ALL dilemmas.

# Section 8: Interaction Constraints (post-prune)
interaction_constraints_prompt: |
  You are identifying pairwise dilemma interactions for a SEED stage.

  Some dilemmas interact with each other — they share characters, have causal
  dependencies, or compete for narrative resources. MOST pairs have NO
  interaction. It is normal and expected to return an empty list.

  ## Constraint Types

  - **shared_entity**: Both dilemmas involve the same character, location, or
    object as a central element. Example: "both dilemmas center on the mentor
    character, so the mentor's arc must be consistent across both."
  - **causal_chain**: Resolving dilemma A directly affects dilemma B. Example:
    "whether the bridge is destroyed (dilemma A) determines access to the
    fortress (dilemma B)."
  - **resource_conflict**: Both dilemmas compete for the same limited narrative
    resource (time, character attention, location availability). Example:
    "both dilemmas need the protagonist at the same location simultaneously."

  ## What NOT to Do
  - Do NOT invent constraints for pairs not in the Candidate Pairs list
  - Do NOT force constraints where none exist — empty list is fine
  - Do NOT use constraint_type values other than the three above

  GOOD constraint: "Both dilemmas involve the mentor (shared_entity), so the
  mentor's betrayal in dilemma A affects trust in dilemma B."
  BAD constraint: "Both dilemmas are thematically about trust" (thematic
  similarity is NOT a structural constraint).

  ## Context

  {candidate_pairs_context}

  ## Schema
  Return a JSON object with an "interaction_constraints" array:
  ```json
  {{
    "interaction_constraints": [
      {{
        "dilemma_a": "dilemma::first_id",
        "dilemma_b": "dilemma::second_id",
        "constraint_type": "shared_entity",
        "description": "The observable structural fact (1-3 sentences, max ~500 chars).",
        "reasoning": "Why this matters for story structure (1-2 sentences)."
      }}
    ]
  }}
  ```

  If no interactions exist (common), return an empty array:
  ```json
  {{
    "interaction_constraints": []
  }}
  ```

  If the Context says "No candidate pairs", return the empty array above immediately.

  ## Rules
  - ONLY consider pairs from the ### Candidate Pairs list in the Context
  - Use canonical ordering: dilemma_a < dilemma_b (alphabetically)
  - Most stories have 0-2 constraints. Empty list is expected and normal.
  - `reasoning` must explain the structural (not thematic) relationship

  ## REMINDER
  ONLY use pairs from the Candidate Pairs list. Empty list is normal. Do NOT invent constraints.

  ## Output
  Return ONLY valid JSON with the "interaction_constraints" array. An empty array is expected.

components: []
